/* tslint:disable */
/* eslint-disable */
/**
 * TrackBot App API
 * Comprehensive API for the TrackBot Application helping in logging workouts, exercises and nutrition using AI.  This API provides endpoints for: - User management - Workout tracking and management - Exercise logging (cardio and weight training) - AI conversation and messaging  All timestamps are in ISO 8601 format (UTC). 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: utkarshkhandelwal2011@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BaseExercise
 */
export interface BaseExercise {
    /**
     * Unique identifier for the exercise. Created by the database.
     * @type {number}
     * @memberof BaseExercise
     */
    'id': number;
    /**
     * ID of the workout this exercise belongs to. Obtained from the workout table.
     * @type {number}
     * @memberof BaseExercise
     */
    'workout_id': number;
    /**
     * Name of the exercise
     * @type {string}
     * @memberof BaseExercise
     */
    'name': string;
    /**
     * 
     * @type {ExerciseType}
     * @memberof BaseExercise
     */
    'type': ExerciseType;
    /**
     * Additional notes about the exercise
     * @type {string}
     * @memberof BaseExercise
     */
    'notes'?: string;
    /**
     * Timestamp when the exercise was created. Created by the database.
     * @type {string}
     * @memberof BaseExercise
     */
    'created_at': string;
}


/**
 * 
 * @export
 * @interface CardioExercise
 */
export interface CardioExercise {
    /**
     * Unique identifier for the exercise. Created by the database.
     * @type {number}
     * @memberof CardioExercise
     */
    'id': number;
    /**
     * ID of the workout this exercise belongs to. Obtained from the workout table.
     * @type {number}
     * @memberof CardioExercise
     */
    'workout_id': number;
    /**
     * Name of the exercise
     * @type {string}
     * @memberof CardioExercise
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CardioExercise
     */
    'type': CardioExerciseTypeEnum;
    /**
     * Additional notes about the exercise
     * @type {string}
     * @memberof CardioExercise
     */
    'notes'?: string;
    /**
     * Timestamp when the exercise was created. Created by the database.
     * @type {string}
     * @memberof CardioExercise
     */
    'created_at': string;
    /**
     * Distance covered in meters
     * @type {number}
     * @memberof CardioExercise
     */
    'distance': number;
    /**
     * Duration in seconds
     * @type {number}
     * @memberof CardioExercise
     */
    'duration': number;
}

export const CardioExerciseTypeEnum = {
    Cardio: 'cardio'
} as const;

export type CardioExerciseTypeEnum = typeof CardioExerciseTypeEnum[keyof typeof CardioExerciseTypeEnum];

/**
 * 
 * @export
 * @interface Conversation
 */
export interface Conversation {
    /**
     * Unique identifier for the conversation. Created by the database.
     * @type {number}
     * @memberof Conversation
     */
    'id': number;
    /**
     * ID of the user who owns this conversation. Obtained from the user table.
     * @type {number}
     * @memberof Conversation
     */
    'user_id': number;
    /**
     * Title of the conversation. This is the title of the conversation.
     * @type {string}
     * @memberof Conversation
     */
    'title': string;
    /**
     * Timestamp when the conversation was created. Created by the database.
     * @type {string}
     * @memberof Conversation
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface CreateCardioExerciseRequest
 */
export interface CreateCardioExerciseRequest {
    /**
     * Name of the exercise
     * @type {string}
     * @memberof CreateCardioExerciseRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCardioExerciseRequest
     */
    'type': CreateCardioExerciseRequestTypeEnum;
    /**
     * Additional notes
     * @type {string}
     * @memberof CreateCardioExerciseRequest
     */
    'notes'?: string;
    /**
     * Distance in meters
     * @type {number}
     * @memberof CreateCardioExerciseRequest
     */
    'distance': number;
    /**
     * Duration in seconds
     * @type {number}
     * @memberof CreateCardioExerciseRequest
     */
    'duration': number;
}

export const CreateCardioExerciseRequestTypeEnum = {
    Cardio: 'cardio'
} as const;

export type CreateCardioExerciseRequestTypeEnum = typeof CreateCardioExerciseRequestTypeEnum[keyof typeof CreateCardioExerciseRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateConversationRequest
 */
export interface CreateConversationRequest {
    /**
     * Title of the conversation
     * @type {string}
     * @memberof CreateConversationRequest
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface CreateConversationResponse
 */
export interface CreateConversationResponse {
    /**
     * ID of the created conversation. Created by the database.
     * @type {number}
     * @memberof CreateConversationResponse
     */
    'id': number;
}
/**
 * @type CreateExerciseRequest
 * @export
 */
export type CreateExerciseRequest = { type: 'cardio' } & CreateCardioExerciseRequest | { type: 'weights' } & CreateWeightExerciseRequest;

/**
 * 
 * @export
 * @interface CreateExerciseResponse
 */
export interface CreateExerciseResponse {
    /**
     * ID of the created exercise
     * @type {number}
     * @memberof CreateExerciseResponse
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface CreateMessageRequest
 */
export interface CreateMessageRequest {
    /**
     * Content of the message. This is the message that the user or assistant sends.
     * @type {string}
     * @memberof CreateMessageRequest
     */
    'content': string;
    /**
     * 
     * @type {MessageType}
     * @memberof CreateMessageRequest
     */
    'message_type': MessageType;
}


/**
 * 
 * @export
 * @interface CreateMessageResponse
 */
export interface CreateMessageResponse {
    /**
     * ID of the created message. Created by the database.
     * @type {number}
     * @memberof CreateMessageResponse
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * User\'s email address. This is the primary key for the user and obtained from the Google Auth.
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * ID of the created user. Created by the database.
     * @type {number}
     * @memberof CreateUserResponse
     */
    'id': number;
    /**
     * User\'s email address. This is the primary key for the user and obtained from the Google Auth.
     * @type {string}
     * @memberof CreateUserResponse
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface CreateWeightExerciseRequest
 */
export interface CreateWeightExerciseRequest {
    /**
     * Name of the exercise
     * @type {string}
     * @memberof CreateWeightExerciseRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWeightExerciseRequest
     */
    'type': CreateWeightExerciseRequestTypeEnum;
    /**
     * Additional notes
     * @type {string}
     * @memberof CreateWeightExerciseRequest
     */
    'notes'?: string;
    /**
     * Number of sets
     * @type {number}
     * @memberof CreateWeightExerciseRequest
     */
    'sets': number;
    /**
     * Number of repetitions per set
     * @type {number}
     * @memberof CreateWeightExerciseRequest
     */
    'reps': number;
    /**
     * Weight in kilograms
     * @type {number}
     * @memberof CreateWeightExerciseRequest
     */
    'weight': number;
}

export const CreateWeightExerciseRequestTypeEnum = {
    Weights: 'weights'
} as const;

export type CreateWeightExerciseRequestTypeEnum = typeof CreateWeightExerciseRequestTypeEnum[keyof typeof CreateWeightExerciseRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateWorkoutRequest
 */
export interface CreateWorkoutRequest {
    /**
     * ID of the user creating the workout
     * @type {number}
     * @memberof CreateWorkoutRequest
     */
    'user_id'?: number;
}
/**
 * 
 * @export
 * @interface CreateWorkoutResponse
 */
export interface CreateWorkoutResponse {
    /**
     * ID of the created workout
     * @type {number}
     * @memberof CreateWorkoutResponse
     */
    'id': number;
}
/**
 * @type Exercise
 * @export
 */
export type Exercise = { type: 'cardio' } & CardioExercise | { type: 'weights' } & WeightExercise;

/**
 * Type of exercise
 * @export
 * @enum {string}
 */

export const ExerciseType = {
    Cardio: 'cardio',
    Weights: 'weights'
} as const;

export type ExerciseType = typeof ExerciseType[keyof typeof ExerciseType];


/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * Unique identifier for the message. Created by the database.
     * @type {number}
     * @memberof Message
     */
    'id': number;
    /**
     * ID of the conversation this message belongs to. Obtained from the conversation table.
     * @type {number}
     * @memberof Message
     */
    'conversation_id': number;
    /**
     * ID of the user who sent this message. Obtained from the user table.
     * @type {number}
     * @memberof Message
     */
    'user_id': number;
    /**
     * Content of the message. This is the message that the user or assistant sends.
     * @type {string}
     * @memberof Message
     */
    'content': string;
    /**
     * 
     * @type {MessageType}
     * @memberof Message
     */
    'message_type': MessageType;
    /**
     * Timestamp when the message was created. Created by the database.
     * @type {string}
     * @memberof Message
     */
    'created_at': string;
}


/**
 * Type of message sender
 * @export
 * @enum {string}
 */

export const MessageType = {
    User: 'user',
    Assistant: 'assistant',
    System: 'system'
} as const;

export type MessageType = typeof MessageType[keyof typeof MessageType];


/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error code
     * @type {string}
     * @memberof ModelError
     */
    'code': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * Additional error details
     * @type {{ [key: string]: any; }}
     * @memberof ModelError
     */
    'details'?: { [key: string]: any; };
}
/**
 * @type UpdateExerciseRequest
 * @export
 */
export type UpdateExerciseRequest = { type: 'cardio' } & CreateCardioExerciseRequest | { type: 'weights' } & CreateWeightExerciseRequest;

/**
 * 
 * @export
 * @interface UpdateWorkoutRequest
 */
export interface UpdateWorkoutRequest {
    /**
     * ID of the user who owns the workout
     * @type {number}
     * @memberof UpdateWorkoutRequest
     */
    'user_id'?: number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier for the user. Created by the database.
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * User\'s email address. This is the primary key for the user and obtained from the Google Auth.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * Timestamp when the user was created. Created by the database.
     * @type {string}
     * @memberof User
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface WeightExercise
 */
export interface WeightExercise {
    /**
     * Unique identifier for the exercise. Created by the database.
     * @type {number}
     * @memberof WeightExercise
     */
    'id': number;
    /**
     * ID of the workout this exercise belongs to. Obtained from the workout table.
     * @type {number}
     * @memberof WeightExercise
     */
    'workout_id': number;
    /**
     * Name of the exercise
     * @type {string}
     * @memberof WeightExercise
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WeightExercise
     */
    'type': WeightExerciseTypeEnum;
    /**
     * Additional notes about the exercise
     * @type {string}
     * @memberof WeightExercise
     */
    'notes'?: string;
    /**
     * Timestamp when the exercise was created. Created by the database.
     * @type {string}
     * @memberof WeightExercise
     */
    'created_at': string;
    /**
     * Number of sets
     * @type {number}
     * @memberof WeightExercise
     */
    'sets': number;
    /**
     * Number of repetitions per set
     * @type {number}
     * @memberof WeightExercise
     */
    'reps': number;
    /**
     * Weight in kilograms
     * @type {number}
     * @memberof WeightExercise
     */
    'weight': number;
}

export const WeightExerciseTypeEnum = {
    Weights: 'weights'
} as const;

export type WeightExerciseTypeEnum = typeof WeightExerciseTypeEnum[keyof typeof WeightExerciseTypeEnum];

/**
 * 
 * @export
 * @interface Workout
 */
export interface Workout {
    /**
     * Unique identifier for the workout. Created by the database.
     * @type {number}
     * @memberof Workout
     */
    'id': number;
    /**
     * ID of the user who owns this workout. Obtained from the user table.
     * @type {number}
     * @memberof Workout
     */
    'user_id': number;
    /**
     * Timestamp when the workout was created. Created by the database.
     * @type {string}
     * @memberof Workout
     */
    'created_at': string;
    /**
     * Timestamp when the workout was last updated. Created by the database.
     * @type {string}
     * @memberof Workout
     */
    'updated_at': string;
}
/**
 * 
 * @export
 * @interface WorkoutListParams
 */
export interface WorkoutListParams {
    /**
     * ID of the user to filter workouts
     * @type {number}
     * @memberof WorkoutListParams
     */
    'user_id'?: number;
    /**
     * Filter by year (YYYY format)
     * @type {string}
     * @memberof WorkoutListParams
     */
    'year'?: string;
    /**
     * Filter by month (MM format)
     * @type {string}
     * @memberof WorkoutListParams
     */
    'month'?: string;
    /**
     * Filter by day (DD format)
     * @type {string}
     * @memberof WorkoutListParams
     */
    'day'?: string;
}

/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Start a new conversation with the AI assistant
         * @summary Create a new conversation
         * @param {number} userId User ID
         * @param {CreateConversationRequest} createConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation: async (userId: number, createConversationRequest: CreateConversationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createConversation', 'userId', userId)
            // verify required parameter 'createConversationRequest' is not null or undefined
            assertParamExists('createConversation', 'createConversationRequest', createConversationRequest)
            const localVarPath = `/users/{userId}/conversations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConversationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a conversation and all associated messages
         * @summary Delete conversation
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation: async (conversationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteConversation', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversationId}`
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific conversation by its ID
         * @summary Get conversation by ID
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationById: async (conversationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getConversationById', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversationId}`
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all conversations for a specific user
         * @summary List conversations for a user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listConversations', 'userId', userId)
            const localVarPath = `/users/{userId}/conversations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Start a new conversation with the AI assistant
         * @summary Create a new conversation
         * @param {number} userId User ID
         * @param {CreateConversationRequest} createConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversation(userId: number, createConversationRequest: CreateConversationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversation(userId, createConversationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.createConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a conversation and all associated messages
         * @summary Delete conversation
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversation(conversationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversation(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.deleteConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific conversation by its ID
         * @summary Get conversation by ID
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationById(conversationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Conversation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationById(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.getConversationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all conversations for a specific user
         * @summary List conversations for a user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversations(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Conversation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConversations(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.listConversations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationsApiFp(configuration)
    return {
        /**
         * Start a new conversation with the AI assistant
         * @summary Create a new conversation
         * @param {number} userId User ID
         * @param {CreateConversationRequest} createConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation(userId: number, createConversationRequest: CreateConversationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateConversationResponse> {
            return localVarFp.createConversation(userId, createConversationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a conversation and all associated messages
         * @summary Delete conversation
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation(conversationId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteConversation(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific conversation by its ID
         * @summary Get conversation by ID
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationById(conversationId: number, options?: RawAxiosRequestConfig): AxiosPromise<Conversation> {
            return localVarFp.getConversationById(conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all conversations for a specific user
         * @summary List conversations for a user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Conversation>> {
            return localVarFp.listConversations(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
    /**
     * Start a new conversation with the AI assistant
     * @summary Create a new conversation
     * @param {number} userId User ID
     * @param {CreateConversationRequest} createConversationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public createConversation(userId: number, createConversationRequest: CreateConversationRequest, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).createConversation(userId, createConversationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a conversation and all associated messages
     * @summary Delete conversation
     * @param {number} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public deleteConversation(conversationId: number, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).deleteConversation(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific conversation by its ID
     * @summary Get conversation by ID
     * @param {number} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public getConversationById(conversationId: number, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).getConversationById(conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all conversations for a specific user
     * @summary List conversations for a user
     * @param {number} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public listConversations(userId: number, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).listConversations(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExercisesApi - axios parameter creator
 * @export
 */
export const ExercisesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new exercise to a workout (cardio or weight training)
         * @summary Create a new exercise
         * @param {number} workoutId Workout ID
         * @param {CreateExerciseRequest} createExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExercise: async (workoutId: number, createExerciseRequest: CreateExerciseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('createExercise', 'workoutId', workoutId)
            // verify required parameter 'createExerciseRequest' is not null or undefined
            assertParamExists('createExercise', 'createExerciseRequest', createExerciseRequest)
            const localVarPath = `/workouts/{workoutId}/exercises`
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExerciseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an exercise from a workout
         * @summary Delete exercise
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExercise: async (exerciseId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('deleteExercise', 'exerciseId', exerciseId)
            const localVarPath = `/exercises/{exerciseId}`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific exercise by its ID
         * @summary Get exercise by ID
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseById: async (exerciseId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('getExerciseById', 'exerciseId', exerciseId)
            const localVarPath = `/exercises/{exerciseId}`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all exercises for a specific workout
         * @summary List exercises for a workout
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExercises: async (workoutId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('listExercises', 'workoutId', workoutId)
            const localVarPath = `/workouts/{workoutId}/exercises`
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing exercise
         * @summary Update exercise
         * @param {number} exerciseId Exercise ID
         * @param {UpdateExerciseRequest} updateExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExercise: async (exerciseId: number, updateExerciseRequest: UpdateExerciseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('updateExercise', 'exerciseId', exerciseId)
            // verify required parameter 'updateExerciseRequest' is not null or undefined
            assertParamExists('updateExercise', 'updateExerciseRequest', updateExerciseRequest)
            const localVarPath = `/exercises/{exerciseId}`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateExerciseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExercisesApi - functional programming interface
 * @export
 */
export const ExercisesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExercisesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new exercise to a workout (cardio or weight training)
         * @summary Create a new exercise
         * @param {number} workoutId Workout ID
         * @param {CreateExerciseRequest} createExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExercise(workoutId: number, createExerciseRequest: CreateExerciseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateExerciseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExercise(workoutId, createExerciseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.createExercise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an exercise from a workout
         * @summary Delete exercise
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExercise(exerciseId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExercise(exerciseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.deleteExercise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific exercise by its ID
         * @summary Get exercise by ID
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExerciseById(exerciseId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exercise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExerciseById(exerciseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.getExerciseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all exercises for a specific workout
         * @summary List exercises for a workout
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExercises(workoutId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Exercise>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExercises(workoutId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.listExercises']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing exercise
         * @summary Update exercise
         * @param {number} exerciseId Exercise ID
         * @param {UpdateExerciseRequest} updateExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExercise(exerciseId: number, updateExerciseRequest: UpdateExerciseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exercise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExercise(exerciseId, updateExerciseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.updateExercise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExercisesApi - factory interface
 * @export
 */
export const ExercisesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExercisesApiFp(configuration)
    return {
        /**
         * Add a new exercise to a workout (cardio or weight training)
         * @summary Create a new exercise
         * @param {number} workoutId Workout ID
         * @param {CreateExerciseRequest} createExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExercise(workoutId: number, createExerciseRequest: CreateExerciseRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateExerciseResponse> {
            return localVarFp.createExercise(workoutId, createExerciseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an exercise from a workout
         * @summary Delete exercise
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExercise(exerciseId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteExercise(exerciseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific exercise by its ID
         * @summary Get exercise by ID
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseById(exerciseId: number, options?: RawAxiosRequestConfig): AxiosPromise<Exercise> {
            return localVarFp.getExerciseById(exerciseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all exercises for a specific workout
         * @summary List exercises for a workout
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExercises(workoutId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Exercise>> {
            return localVarFp.listExercises(workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing exercise
         * @summary Update exercise
         * @param {number} exerciseId Exercise ID
         * @param {UpdateExerciseRequest} updateExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExercise(exerciseId: number, updateExerciseRequest: UpdateExerciseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Exercise> {
            return localVarFp.updateExercise(exerciseId, updateExerciseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExercisesApi - object-oriented interface
 * @export
 * @class ExercisesApi
 * @extends {BaseAPI}
 */
export class ExercisesApi extends BaseAPI {
    /**
     * Add a new exercise to a workout (cardio or weight training)
     * @summary Create a new exercise
     * @param {number} workoutId Workout ID
     * @param {CreateExerciseRequest} createExerciseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public createExercise(workoutId: number, createExerciseRequest: CreateExerciseRequest, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).createExercise(workoutId, createExerciseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an exercise from a workout
     * @summary Delete exercise
     * @param {number} exerciseId Exercise ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public deleteExercise(exerciseId: number, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).deleteExercise(exerciseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific exercise by its ID
     * @summary Get exercise by ID
     * @param {number} exerciseId Exercise ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public getExerciseById(exerciseId: number, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).getExerciseById(exerciseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all exercises for a specific workout
     * @summary List exercises for a workout
     * @param {number} workoutId Workout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public listExercises(workoutId: number, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).listExercises(workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing exercise
     * @summary Update exercise
     * @param {number} exerciseId Exercise ID
     * @param {UpdateExerciseRequest} updateExerciseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public updateExercise(exerciseId: number, updateExerciseRequest: UpdateExerciseRequest, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).updateExercise(exerciseId, updateExerciseRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send a new message in a conversation
         * @summary Create a new message
         * @param {number} conversationId Conversation ID
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage: async (conversationId: number, createMessageRequest: CreateMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('createMessage', 'conversationId', conversationId)
            // verify required parameter 'createMessageRequest' is not null or undefined
            assertParamExists('createMessage', 'createMessageRequest', createMessageRequest)
            const localVarPath = `/conversations/{conversationId}/messages`
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a message from a conversation
         * @summary Delete message
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessage', 'messageId', messageId)
            const localVarPath = `/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific message by its ID
         * @summary Get message by ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById: async (messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessageById', 'messageId', messageId)
            const localVarPath = `/messages/{messageId}`
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all messages in a specific conversation
         * @summary List messages in a conversation
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages: async (conversationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('listMessages', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversationId}/messages`
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Send a new message in a conversation
         * @summary Create a new message
         * @param {number} conversationId Conversation ID
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessage(conversationId: number, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(conversationId, createMessageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.createMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a message from a conversation
         * @summary Delete message
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.deleteMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific message by its ID
         * @summary Get message by ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageById(messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageById(messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.getMessageById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all messages in a specific conversation
         * @summary List messages in a conversation
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessages(conversationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessages(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.listMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * Send a new message in a conversation
         * @summary Create a new message
         * @param {number} conversationId Conversation ID
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage(conversationId: number, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateMessageResponse> {
            return localVarFp.createMessage(conversationId, createMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a message from a conversation
         * @summary Delete message
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMessage(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific message by its ID
         * @summary Get message by ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.getMessageById(messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all messages in a specific conversation
         * @summary List messages in a conversation
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(conversationId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.listMessages(conversationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * Send a new message in a conversation
     * @summary Create a new message
     * @param {number} conversationId Conversation ID
     * @param {CreateMessageRequest} createMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public createMessage(conversationId: number, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).createMessage(conversationId, createMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a message from a conversation
     * @summary Delete message
     * @param {number} messageId Message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public deleteMessage(messageId: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).deleteMessage(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific message by its ID
     * @summary Get message by ID
     * @param {number} messageId Message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessageById(messageId: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).getMessageById(messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all messages in a specific conversation
     * @summary List messages in a conversation
     * @param {number} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public listMessages(conversationId: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).listMessages(conversationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user account
         * @summary Create a new user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user and all associated data
         * @summary Delete user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a user by their email address
         * @summary Get user by email
         * @param {string} email User email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByEmail: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('getUserByEmail', 'email', email)
            const localVarPath = `/users/email/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific user by their ID
         * @summary Get user by ID
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all users in the system
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new user account
         * @summary Create a new user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a user and all associated data
         * @summary Delete user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a user by their email address
         * @summary Get user by email
         * @param {string} email User email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByEmail(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByEmail(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserByEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific user by their ID
         * @summary Get user by ID
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all users in the system
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create a new user account
         * @summary Create a new user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user and all associated data
         * @summary Delete user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a user by their email address
         * @summary Get user by email
         * @param {string} email User email address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByEmail(email: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserByEmail(email, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific user by their ID
         * @summary Get user by ID
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all users in the system
         * @summary List all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new user account
     * @summary Create a new user
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user and all associated data
     * @summary Delete user
     * @param {number} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a user by their email address
     * @summary Get user by email
     * @param {string} email User email address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByEmail(email: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByEmail(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific user by their ID
     * @summary Get user by ID
     * @param {number} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserById(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all users in the system
     * @summary List all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).listUsers(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkoutsApi - axios parameter creator
 * @export
 */
export const WorkoutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new workout session for a user
         * @summary Create a new workout
         * @param {number} userId User ID
         * @param {CreateWorkoutRequest} createWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkout: async (userId: number, createWorkoutRequest: CreateWorkoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createWorkout', 'userId', userId)
            // verify required parameter 'createWorkoutRequest' is not null or undefined
            assertParamExists('createWorkout', 'createWorkoutRequest', createWorkoutRequest)
            const localVarPath = `/users/{userId}/workouts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workout and all associated exercises
         * @summary Delete workout
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkout: async (workoutId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('deleteWorkout', 'workoutId', workoutId)
            const localVarPath = `/workouts/{workoutId}`
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific workout by its ID
         * @summary Get workout by ID
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkoutById: async (workoutId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('getWorkoutById', 'workoutId', workoutId)
            const localVarPath = `/workouts/{workoutId}`
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all workouts for a specific user with optional date filtering
         * @summary List workouts for a user
         * @param {number} userId User ID
         * @param {string} [year] Filter by year (YYYY format)
         * @param {string} [month] Filter by month (MM format)
         * @param {string} [day] Filter by day (DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkouts: async (userId: number, year?: string, month?: string, day?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listWorkouts', 'userId', userId)
            const localVarPath = `/users/{userId}/workouts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing workout
         * @summary Update workout
         * @param {number} workoutId Workout ID
         * @param {UpdateWorkoutRequest} updateWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkout: async (workoutId: number, updateWorkoutRequest: UpdateWorkoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('updateWorkout', 'workoutId', workoutId)
            // verify required parameter 'updateWorkoutRequest' is not null or undefined
            assertParamExists('updateWorkout', 'updateWorkoutRequest', updateWorkoutRequest)
            const localVarPath = `/workouts/{workoutId}`
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkoutsApi - functional programming interface
 * @export
 */
export const WorkoutsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkoutsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new workout session for a user
         * @summary Create a new workout
         * @param {number} userId User ID
         * @param {CreateWorkoutRequest} createWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkout(userId: number, createWorkoutRequest: CreateWorkoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWorkoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkout(userId, createWorkoutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.createWorkout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a workout and all associated exercises
         * @summary Delete workout
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkout(workoutId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkout(workoutId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.deleteWorkout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific workout by its ID
         * @summary Get workout by ID
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkoutById(workoutId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkoutById(workoutId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.getWorkoutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all workouts for a specific user with optional date filtering
         * @summary List workouts for a user
         * @param {number} userId User ID
         * @param {string} [year] Filter by year (YYYY format)
         * @param {string} [month] Filter by month (MM format)
         * @param {string} [day] Filter by day (DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkouts(userId: number, year?: string, month?: string, day?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workout>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkouts(userId, year, month, day, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.listWorkouts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing workout
         * @summary Update workout
         * @param {number} workoutId Workout ID
         * @param {UpdateWorkoutRequest} updateWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkout(workoutId: number, updateWorkoutRequest: UpdateWorkoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkout(workoutId, updateWorkoutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.updateWorkout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkoutsApi - factory interface
 * @export
 */
export const WorkoutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkoutsApiFp(configuration)
    return {
        /**
         * Create a new workout session for a user
         * @summary Create a new workout
         * @param {number} userId User ID
         * @param {CreateWorkoutRequest} createWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkout(userId: number, createWorkoutRequest: CreateWorkoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateWorkoutResponse> {
            return localVarFp.createWorkout(userId, createWorkoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workout and all associated exercises
         * @summary Delete workout
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkout(workoutId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkout(workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific workout by its ID
         * @summary Get workout by ID
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkoutById(workoutId: number, options?: RawAxiosRequestConfig): AxiosPromise<Workout> {
            return localVarFp.getWorkoutById(workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all workouts for a specific user with optional date filtering
         * @summary List workouts for a user
         * @param {number} userId User ID
         * @param {string} [year] Filter by year (YYYY format)
         * @param {string} [month] Filter by month (MM format)
         * @param {string} [day] Filter by day (DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkouts(userId: number, year?: string, month?: string, day?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Workout>> {
            return localVarFp.listWorkouts(userId, year, month, day, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing workout
         * @summary Update workout
         * @param {number} workoutId Workout ID
         * @param {UpdateWorkoutRequest} updateWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkout(workoutId: number, updateWorkoutRequest: UpdateWorkoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workout> {
            return localVarFp.updateWorkout(workoutId, updateWorkoutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkoutsApi - object-oriented interface
 * @export
 * @class WorkoutsApi
 * @extends {BaseAPI}
 */
export class WorkoutsApi extends BaseAPI {
    /**
     * Create a new workout session for a user
     * @summary Create a new workout
     * @param {number} userId User ID
     * @param {CreateWorkoutRequest} createWorkoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public createWorkout(userId: number, createWorkoutRequest: CreateWorkoutRequest, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).createWorkout(userId, createWorkoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workout and all associated exercises
     * @summary Delete workout
     * @param {number} workoutId Workout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public deleteWorkout(workoutId: number, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).deleteWorkout(workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific workout by its ID
     * @summary Get workout by ID
     * @param {number} workoutId Workout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public getWorkoutById(workoutId: number, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).getWorkoutById(workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all workouts for a specific user with optional date filtering
     * @summary List workouts for a user
     * @param {number} userId User ID
     * @param {string} [year] Filter by year (YYYY format)
     * @param {string} [month] Filter by month (MM format)
     * @param {string} [day] Filter by day (DD format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public listWorkouts(userId: number, year?: string, month?: string, day?: string, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).listWorkouts(userId, year, month, day, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing workout
     * @summary Update workout
     * @param {number} workoutId Workout ID
     * @param {UpdateWorkoutRequest} updateWorkoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public updateWorkout(workoutId: number, updateWorkoutRequest: UpdateWorkoutRequest, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).updateWorkout(workoutId, updateWorkoutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



