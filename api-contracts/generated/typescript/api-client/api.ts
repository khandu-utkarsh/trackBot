/* tslint:disable */
/* eslint-disable */
/**
 * TrackBot App API
 * Comprehensive API for the TrackBot Application helping in logging workouts, exercises and nutrition using AI.  This API provides endpoints for: - User management - Workout tracking and management - Exercise logging (cardio and weight training) - AI conversation and messaging  All timestamps are in ISO 8601 format (UTC). 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: utkarshkhandelwal2011@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BaseExercise
 */
export interface BaseExercise {
    /**
     * Unique identifier for the exercise.
     * @type {number}
     * @memberof BaseExercise
     */
    'id': number;
    /**
     * ID of the workout this exercise belongs to.
     * @type {number}
     * @memberof BaseExercise
     */
    'workout_id': number;
    /**
     * Name of the exercise
     * @type {string}
     * @memberof BaseExercise
     */
    'name': string;
    /**
     * 
     * @type {ExerciseType}
     * @memberof BaseExercise
     */
    'type': ExerciseType;
    /**
     * Additional notes
     * @type {string}
     * @memberof BaseExercise
     */
    'notes'?: string;
    /**
     * Timestamp when the exercise was created.
     * @type {string}
     * @memberof BaseExercise
     */
    'created_at': string;
}


/**
 * 
 * @export
 * @interface CardioExercise
 */
export interface CardioExercise {
    /**
     * Unique identifier for the exercise.
     * @type {number}
     * @memberof CardioExercise
     */
    'id': number;
    /**
     * ID of the workout this exercise belongs to.
     * @type {number}
     * @memberof CardioExercise
     */
    'workout_id': number;
    /**
     * Name of the exercise
     * @type {string}
     * @memberof CardioExercise
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CardioExercise
     */
    'type': CardioExerciseTypeEnum;
    /**
     * Additional notes
     * @type {string}
     * @memberof CardioExercise
     */
    'notes'?: string;
    /**
     * Timestamp when the exercise was created.
     * @type {string}
     * @memberof CardioExercise
     */
    'created_at': string;
    /**
     * Distance in meters
     * @type {number}
     * @memberof CardioExercise
     */
    'distance': number;
    /**
     * Duration in seconds
     * @type {number}
     * @memberof CardioExercise
     */
    'duration': number;
}

export const CardioExerciseTypeEnum = {
    Cardio: 'cardio'
} as const;

export type CardioExerciseTypeEnum = typeof CardioExerciseTypeEnum[keyof typeof CardioExerciseTypeEnum];

/**
 * Represents a conversation.
 * @export
 * @interface Conversation
 */
export interface Conversation {
    /**
     * Unique ID for the conversation.
     * @type {number}
     * @memberof Conversation
     */
    'id': number;
    /**
     * ID of the user.
     * @type {number}
     * @memberof Conversation
     */
    'user_id': number;
    /**
     * Conversation title.
     * @type {string}
     * @memberof Conversation
     */
    'title': string;
    /**
     * Timestamp of creation.
     * @type {string}
     * @memberof Conversation
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface CreateCardioExerciseRequest
 */
export interface CreateCardioExerciseRequest {
    /**
     * Name of the exercise
     * @type {string}
     * @memberof CreateCardioExerciseRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCardioExerciseRequest
     */
    'type': CreateCardioExerciseRequestTypeEnum;
    /**
     * Additional notes
     * @type {string}
     * @memberof CreateCardioExerciseRequest
     */
    'notes'?: string;
    /**
     * Distance in meters
     * @type {number}
     * @memberof CreateCardioExerciseRequest
     */
    'distance': number;
    /**
     * Duration in seconds
     * @type {number}
     * @memberof CreateCardioExerciseRequest
     */
    'duration': number;
}

export const CreateCardioExerciseRequestTypeEnum = {
    Cardio: 'cardio'
} as const;

export type CreateCardioExerciseRequestTypeEnum = typeof CreateCardioExerciseRequestTypeEnum[keyof typeof CreateCardioExerciseRequestTypeEnum];

/**
 * Request to create a conversation.
 * @export
 * @interface CreateConversationRequest
 */
export interface CreateConversationRequest {
    /**
     * Title of the conversation.
     * @type {string}
     * @memberof CreateConversationRequest
     */
    'title': string;
}
/**
 * Response after creating a conversation.
 * @export
 * @interface CreateConversationResponse
 */
export interface CreateConversationResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateConversationResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateConversationResponse
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof CreateConversationResponse
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateConversationResponse
     */
    'created_at': string;
}
/**
 * @type CreateExerciseRequest
 * @export
 */
export type CreateExerciseRequest = { type: 'cardio' } & CreateCardioExerciseRequest | { type: 'weights' } & CreateWeightExerciseRequest;

/**
 * Payload to create a new message.
 * @export
 * @interface CreateMessageRequest
 */
export interface CreateMessageRequest {
    /**
     * Content of the message.
     * @type {string}
     * @memberof CreateMessageRequest
     */
    'content': string;
    /**
     * 
     * @type {MessageType}
     * @memberof CreateMessageRequest
     */
    'message_type': MessageType;
}


/**
 * 
 * @export
 * @interface CreateWeightExerciseRequest
 */
export interface CreateWeightExerciseRequest {
    /**
     * Name of the exercise
     * @type {string}
     * @memberof CreateWeightExerciseRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWeightExerciseRequest
     */
    'type': CreateWeightExerciseRequestTypeEnum;
    /**
     * Additional notes
     * @type {string}
     * @memberof CreateWeightExerciseRequest
     */
    'notes'?: string;
    /**
     * Number of sets
     * @type {number}
     * @memberof CreateWeightExerciseRequest
     */
    'sets': number;
    /**
     * Reps per set
     * @type {number}
     * @memberof CreateWeightExerciseRequest
     */
    'reps': number;
    /**
     * Weight in kg
     * @type {number}
     * @memberof CreateWeightExerciseRequest
     */
    'weight': number;
}

export const CreateWeightExerciseRequestTypeEnum = {
    Weights: 'weights'
} as const;

export type CreateWeightExerciseRequestTypeEnum = typeof CreateWeightExerciseRequestTypeEnum[keyof typeof CreateWeightExerciseRequestTypeEnum];

/**
 * Request to create a new workout.
 * @export
 * @interface CreateWorkoutRequest
 */
export interface CreateWorkoutRequest {
    /**
     * ID of the user creating the workout.
     * @type {number}
     * @memberof CreateWorkoutRequest
     */
    'user_id'?: number;
}
/**
 * Response returned after creating a workout.
 * @export
 * @interface CreateWorkoutResponse
 */
export interface CreateWorkoutResponse {
    /**
     * ID of the created workout.
     * @type {number}
     * @memberof CreateWorkoutResponse
     */
    'id': number;
}
/**
 * Request to delete a conversation and all its messages.
 * @export
 * @interface DeleteConversationRequest
 */
export interface DeleteConversationRequest {
    /**
     * Confirmation flag to prevent accidental deletion.
     * @type {boolean}
     * @memberof DeleteConversationRequest
     */
    'confirm'?: boolean;
}
/**
 * Response after successfully deleting a conversation and its messages.
 * @export
 * @interface DeleteConversationResponse
 */
export interface DeleteConversationResponse {
    /**
     * ID of the deleted conversation.
     * @type {number}
     * @memberof DeleteConversationResponse
     */
    'id': number;
    /**
     * Title of the deleted conversation.
     * @type {string}
     * @memberof DeleteConversationResponse
     */
    'title': string;
    /**
     * Timestamp when the conversation was deleted.
     * @type {string}
     * @memberof DeleteConversationResponse
     */
    'deleted_at': string;
    /**
     * Number of messages that were deleted along with the conversation.
     * @type {number}
     * @memberof DeleteConversationResponse
     */
    'messages_deleted_count': number;
}
/**
 * @type Exercise
 * @export
 */
export type Exercise = { type: 'cardio' } & CardioExercise | { type: 'weights' } & WeightExercise;

/**
 * Type of exercise
 * @export
 * @enum {string}
 */

export const ExerciseType = {
    Cardio: 'cardio',
    Strength: 'strength'
} as const;

export type ExerciseType = typeof ExerciseType[keyof typeof ExerciseType];


/**
 * Payload for Google OAuth login.
 * @export
 * @interface GoogleLoginRequest
 */
export interface GoogleLoginRequest {
    /**
     * Google JWT credential token
     * @type {string}
     * @memberof GoogleLoginRequest
     */
    'googleToken': string;
}
/**
 * Request to the LLM service to process a conversation.
 * @export
 * @interface LLMServiceMessageRequest
 */
export interface LLMServiceMessageRequest {
    /**
     * 
     * @type {Array<Message>}
     * @memberof LLMServiceMessageRequest
     */
    'messages': Array<Message>;
    /**
     * ID of the user making the request.
     * @type {number}
     * @memberof LLMServiceMessageRequest
     */
    'user_id': number;
    /**
     * ID of the conversation to which these messages belong.
     * @type {number}
     * @memberof LLMServiceMessageRequest
     */
    'conversation_id': number;
}
/**
 * Response from the LLM service to process a conversation.
 * @export
 * @interface LLMServiceMessageResponse
 */
export interface LLMServiceMessageResponse {
    /**
     * 
     * @type {Message}
     * @memberof LLMServiceMessageResponse
     */
    'message': Message;
    /**
     * Time taken to generate the response in milliseconds.
     * @type {number}
     * @memberof LLMServiceMessageResponse
     */
    'response_time_ms'?: number;
    /**
     * Identifier of the model used to generate the response.
     * @type {string}
     * @memberof LLMServiceMessageResponse
     */
    'model_name'?: string;
}
/**
 * Response containing a list of conversations.
 * @export
 * @interface ListConversationsResponse
 */
export interface ListConversationsResponse {
    /**
     * 
     * @type {Array<Conversation>}
     * @memberof ListConversationsResponse
     */
    'conversations': Array<Conversation>;
}
/**
 * A list of exercises
 * @export
 * @interface ListExercisesResponse
 */
export interface ListExercisesResponse {
    /**
     * 
     * @type {Array<Exercise>}
     * @memberof ListExercisesResponse
     */
    'exercises': Array<Exercise>;
}
/**
 * 
 * @export
 * @interface ListMessagesRequest
 */
export interface ListMessagesRequest {
    /**
     * 
     * @type {number}
     * @memberof ListMessagesRequest
     */
    'conversation_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListMessagesRequest
     */
    'user_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListMessagesRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListMessagesRequest
     */
    'offset'?: number;
}
/**
 * Response containing a list of messages.
 * @export
 * @interface ListMessagesResponse
 */
export interface ListMessagesResponse {
    /**
     * 
     * @type {Array<Message>}
     * @memberof ListMessagesResponse
     */
    'messages': Array<Message>;
}
/**
 * Response containing a list of workouts.
 * @export
 * @interface ListWorkoutsResponse
 */
export interface ListWorkoutsResponse {
    /**
     * 
     * @type {Array<Workout>}
     * @memberof ListWorkoutsResponse
     */
    'workouts': Array<Workout>;
}
/**
 * Represents a message in a conversation.
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * Unique identifier for the message.
     * @type {number}
     * @memberof Message
     */
    'id'?: number;
    /**
     * Conversation ID this message belongs to.
     * @type {number}
     * @memberof Message
     */
    'conversation_id'?: number;
    /**
     * User ID who sent the message.
     * @type {number}
     * @memberof Message
     */
    'user_id'?: number;
    /**
     * Content of the message.
     * @type {string}
     * @memberof Message
     */
    'content': string;
    /**
     * 
     * @type {MessageType}
     * @memberof Message
     */
    'message_type': MessageType;
    /**
     * Creation timestamp.
     * @type {string}
     * @memberof Message
     */
    'created_at'?: string;
    /**
     * Additional metadata passed with the message.
     * @type {object}
     * @memberof Message
     */
    'additional_kwargs'?: object;
    /**
     * Metadata returned by the model provider.
     * @type {object}
     * @memberof Message
     */
    'response_metadata'?: object;
    /**
     * Type of message.
     * @type {string}
     * @memberof Message
     */
    'type'?: MessageTypeEnum;
    /**
     * Optional name of the message sender/tool.
     * @type {string}
     * @memberof Message
     */
    'name'?: string | null;
    /**
     * Unique message ID from the model provider.
     * @type {string}
     * @memberof Message
     */
    'llm_id'?: string;
    /**
     * Tool calls made by the model in this message.
     * @type {Array<object>}
     * @memberof Message
     */
    'tool_calls'?: Array<object>;
    /**
     * Tool calls that failed to parse or execute.
     * @type {Array<object>}
     * @memberof Message
     */
    'invalid_tool_calls'?: Array<object>;
    /**
     * Token usage metadata.
     * @type {object}
     * @memberof Message
     */
    'usage_metadata'?: object;
    /**
     * Whether this message was part of an example conversation.
     * @type {boolean}
     * @memberof Message
     */
    'example'?: boolean;
}

export const MessageTypeEnum = {
    Ai: 'ai',
    Human: 'human'
} as const;

export type MessageTypeEnum = typeof MessageTypeEnum[keyof typeof MessageTypeEnum];

/**
 * Type of message sender
 * @export
 * @enum {string}
 */

export const MessageType = {
    User: 'user',
    Assistant: 'assistant',
    System: 'system'
} as const;

export type MessageType = typeof MessageType[keyof typeof MessageType];


/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error code
     * @type {string}
     * @memberof ModelError
     */
    'code': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * Additional error details
     * @type {{ [key: string]: any; }}
     * @memberof ModelError
     */
    'details'?: { [key: string]: any; };
}
/**
 * Request to update a conversation.
 * @export
 * @interface UpdateConversationRequest
 */
export interface UpdateConversationRequest {
    /**
     * Updated title of the conversation.
     * @type {string}
     * @memberof UpdateConversationRequest
     */
    'title'?: string;
}
/**
 * Request to update a workout.
 * @export
 * @interface UpdateWorkoutRequest
 */
export interface UpdateWorkoutRequest {
    /**
     * ID of the user who owns the workout.
     * @type {number}
     * @memberof UpdateWorkoutRequest
     */
    'user_id'?: number;
}
/**
 * Represents a registered user in the system.
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier for the user. Created by the database.
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * User\'s email address. This is the primary key for the user and obtained from Google Auth.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * User\'s full name from Google profile.
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * User\'s profile picture URL from Google.
     * @type {string}
     * @memberof User
     */
    'picture': string;
    /**
     * Timestamp when the user was created. Created by the database.
     * @type {string}
     * @memberof User
     */
    'created_at'?: string | null;
}
/**
 * 
 * @export
 * @interface WeightExercise
 */
export interface WeightExercise {
    /**
     * Unique identifier for the exercise.
     * @type {number}
     * @memberof WeightExercise
     */
    'id': number;
    /**
     * ID of the workout this exercise belongs to.
     * @type {number}
     * @memberof WeightExercise
     */
    'workout_id': number;
    /**
     * Name of the exercise
     * @type {string}
     * @memberof WeightExercise
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof WeightExercise
     */
    'type': WeightExerciseTypeEnum;
    /**
     * Additional notes
     * @type {string}
     * @memberof WeightExercise
     */
    'notes'?: string;
    /**
     * Timestamp when the exercise was created.
     * @type {string}
     * @memberof WeightExercise
     */
    'created_at': string;
    /**
     * Number of sets
     * @type {number}
     * @memberof WeightExercise
     */
    'sets': number;
    /**
     * Repetitions per set
     * @type {number}
     * @memberof WeightExercise
     */
    'reps': number;
    /**
     * Weight in kilograms
     * @type {number}
     * @memberof WeightExercise
     */
    'weight': number;
}

export const WeightExerciseTypeEnum = {
    Weights: 'weights'
} as const;

export type WeightExerciseTypeEnum = typeof WeightExerciseTypeEnum[keyof typeof WeightExerciseTypeEnum];

/**
 * Represents a workout session.
 * @export
 * @interface Workout
 */
export interface Workout {
    /**
     * Unique identifier for the workout.
     * @type {number}
     * @memberof Workout
     */
    'id': number;
    /**
     * ID of the user who owns the workout.
     * @type {number}
     * @memberof Workout
     */
    'user_id': number;
    /**
     * When the workout was created.
     * @type {string}
     * @memberof Workout
     */
    'created_at': string;
    /**
     * When the workout was last updated.
     * @type {string}
     * @memberof Workout
     */
    'updated_at': string;
}
/**
 * Parameters for filtering workout list.
 * @export
 * @interface WorkoutListParams
 */
export interface WorkoutListParams {
    /**
     * 
     * @type {number}
     * @memberof WorkoutListParams
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkoutListParams
     */
    'year'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkoutListParams
     */
    'month'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkoutListParams
     */
    'day'?: string;
}

/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Start a new conversation with the AI assistant
         * @summary Create a new conversation
         * @param {number} userId User ID
         * @param {CreateConversationRequest} createConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation: async (userId: number, createConversationRequest: CreateConversationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createConversation', 'userId', userId)
            // verify required parameter 'createConversationRequest' is not null or undefined
            assertParamExists('createConversation', 'createConversationRequest', createConversationRequest)
            const localVarPath = `/users/{userId}/conversations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConversationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a conversation and all associated messages
         * @summary Delete conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {DeleteConversationRequest} [deleteConversationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation: async (userId: number, conversationId: number, deleteConversationRequest?: DeleteConversationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteConversation', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteConversation', 'conversationId', conversationId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteConversationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific conversation by its ID
         * @summary Get conversation by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationById: async (userId: number, conversationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getConversationById', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getConversationById', 'conversationId', conversationId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all conversations for a specific user
         * @summary List conversations for a user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listConversations', 'userId', userId)
            const localVarPath = `/users/{userId}/conversations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing conversation
         * @summary Update conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {UpdateConversationRequest} updateConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation: async (userId: number, conversationId: number, updateConversationRequest: UpdateConversationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateConversation', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('updateConversation', 'conversationId', conversationId)
            // verify required parameter 'updateConversationRequest' is not null or undefined
            assertParamExists('updateConversation', 'updateConversationRequest', updateConversationRequest)
            const localVarPath = `/users/{userId}/conversations/{conversationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConversationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Start a new conversation with the AI assistant
         * @summary Create a new conversation
         * @param {number} userId User ID
         * @param {CreateConversationRequest} createConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversation(userId: number, createConversationRequest: CreateConversationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversation(userId, createConversationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.createConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a conversation and all associated messages
         * @summary Delete conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {DeleteConversationRequest} [deleteConversationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversation(userId: number, conversationId: number, deleteConversationRequest?: DeleteConversationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversation(userId, conversationId, deleteConversationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.deleteConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific conversation by its ID
         * @summary Get conversation by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationById(userId: number, conversationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Conversation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationById(userId, conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.getConversationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all conversations for a specific user
         * @summary List conversations for a user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversations(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConversationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConversations(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.listConversations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing conversation
         * @summary Update conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {UpdateConversationRequest} updateConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversation(userId: number, conversationId: number, updateConversationRequest: UpdateConversationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Conversation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversation(userId, conversationId, updateConversationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.updateConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationsApiFp(configuration)
    return {
        /**
         * Start a new conversation with the AI assistant
         * @summary Create a new conversation
         * @param {number} userId User ID
         * @param {CreateConversationRequest} createConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation(userId: number, createConversationRequest: CreateConversationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateConversationResponse> {
            return localVarFp.createConversation(userId, createConversationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a conversation and all associated messages
         * @summary Delete conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {DeleteConversationRequest} [deleteConversationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation(userId: number, conversationId: number, deleteConversationRequest?: DeleteConversationRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteConversationResponse> {
            return localVarFp.deleteConversation(userId, conversationId, deleteConversationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific conversation by its ID
         * @summary Get conversation by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationById(userId: number, conversationId: number, options?: RawAxiosRequestConfig): AxiosPromise<Conversation> {
            return localVarFp.getConversationById(userId, conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all conversations for a specific user
         * @summary List conversations for a user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListConversationsResponse> {
            return localVarFp.listConversations(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing conversation
         * @summary Update conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {UpdateConversationRequest} updateConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation(userId: number, conversationId: number, updateConversationRequest: UpdateConversationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Conversation> {
            return localVarFp.updateConversation(userId, conversationId, updateConversationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
    /**
     * Start a new conversation with the AI assistant
     * @summary Create a new conversation
     * @param {number} userId User ID
     * @param {CreateConversationRequest} createConversationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public createConversation(userId: number, createConversationRequest: CreateConversationRequest, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).createConversation(userId, createConversationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a conversation and all associated messages
     * @summary Delete conversation
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {DeleteConversationRequest} [deleteConversationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public deleteConversation(userId: number, conversationId: number, deleteConversationRequest?: DeleteConversationRequest, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).deleteConversation(userId, conversationId, deleteConversationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific conversation by its ID
     * @summary Get conversation by ID
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public getConversationById(userId: number, conversationId: number, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).getConversationById(userId, conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all conversations for a specific user
     * @summary List conversations for a user
     * @param {number} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public listConversations(userId: number, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).listConversations(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing conversation
     * @summary Update conversation
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {UpdateConversationRequest} updateConversationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public updateConversation(userId: number, conversationId: number, updateConversationRequest: UpdateConversationRequest, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).updateConversation(userId, conversationId, updateConversationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExercisesApi - axios parameter creator
 * @export
 */
export const ExercisesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new exercise to a workout (cardio or weight training)
         * @summary Create a new exercise
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {CreateExerciseRequest} createExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExercise: async (userId: number, workoutId: number, createExerciseRequest: CreateExerciseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createExercise', 'userId', userId)
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('createExercise', 'workoutId', workoutId)
            // verify required parameter 'createExerciseRequest' is not null or undefined
            assertParamExists('createExercise', 'createExerciseRequest', createExerciseRequest)
            const localVarPath = `/users/{userId}/workouts/{workoutId}/exercises`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExerciseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an exercise from a workout
         * @summary Delete exercise
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExercise: async (userId: number, workoutId: number, exerciseId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteExercise', 'userId', userId)
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('deleteExercise', 'workoutId', workoutId)
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('deleteExercise', 'exerciseId', exerciseId)
            const localVarPath = `/users/{userId}/workouts/{workoutId}/exercises/{exerciseId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific exercise by its ID
         * @summary Get exercise by ID
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseById: async (userId: number, workoutId: number, exerciseId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getExerciseById', 'userId', userId)
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('getExerciseById', 'workoutId', workoutId)
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('getExerciseById', 'exerciseId', exerciseId)
            const localVarPath = `/users/{userId}/workouts/{workoutId}/exercises/{exerciseId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all exercises for a specific workout
         * @summary List exercises for a workout
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExercises: async (userId: number, workoutId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listExercises', 'userId', userId)
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('listExercises', 'workoutId', workoutId)
            const localVarPath = `/users/{userId}/workouts/{workoutId}/exercises`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing exercise
         * @summary Update exercise
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {number} exerciseId Exercise ID
         * @param {CreateExerciseRequest} createExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExercise: async (userId: number, workoutId: number, exerciseId: number, createExerciseRequest: CreateExerciseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateExercise', 'userId', userId)
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('updateExercise', 'workoutId', workoutId)
            // verify required parameter 'exerciseId' is not null or undefined
            assertParamExists('updateExercise', 'exerciseId', exerciseId)
            // verify required parameter 'createExerciseRequest' is not null or undefined
            assertParamExists('updateExercise', 'createExerciseRequest', createExerciseRequest)
            const localVarPath = `/users/{userId}/workouts/{workoutId}/exercises/{exerciseId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)))
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createExerciseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExercisesApi - functional programming interface
 * @export
 */
export const ExercisesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExercisesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new exercise to a workout (cardio or weight training)
         * @summary Create a new exercise
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {CreateExerciseRequest} createExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExercise(userId: number, workoutId: number, createExerciseRequest: CreateExerciseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exercise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExercise(userId, workoutId, createExerciseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.createExercise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an exercise from a workout
         * @summary Delete exercise
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExercise(userId: number, workoutId: number, exerciseId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExercise(userId, workoutId, exerciseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.deleteExercise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific exercise by its ID
         * @summary Get exercise by ID
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExerciseById(userId: number, workoutId: number, exerciseId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exercise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExerciseById(userId, workoutId, exerciseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.getExerciseById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all exercises for a specific workout
         * @summary List exercises for a workout
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExercises(userId: number, workoutId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListExercisesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExercises(userId, workoutId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.listExercises']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing exercise
         * @summary Update exercise
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {number} exerciseId Exercise ID
         * @param {CreateExerciseRequest} createExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExercise(userId: number, workoutId: number, exerciseId: number, createExerciseRequest: CreateExerciseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Exercise>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExercise(userId, workoutId, exerciseId, createExerciseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExercisesApi.updateExercise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExercisesApi - factory interface
 * @export
 */
export const ExercisesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExercisesApiFp(configuration)
    return {
        /**
         * Add a new exercise to a workout (cardio or weight training)
         * @summary Create a new exercise
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {CreateExerciseRequest} createExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExercise(userId: number, workoutId: number, createExerciseRequest: CreateExerciseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Exercise> {
            return localVarFp.createExercise(userId, workoutId, createExerciseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an exercise from a workout
         * @summary Delete exercise
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExercise(userId: number, workoutId: number, exerciseId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteExercise(userId, workoutId, exerciseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific exercise by its ID
         * @summary Get exercise by ID
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {number} exerciseId Exercise ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExerciseById(userId: number, workoutId: number, exerciseId: number, options?: RawAxiosRequestConfig): AxiosPromise<Exercise> {
            return localVarFp.getExerciseById(userId, workoutId, exerciseId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all exercises for a specific workout
         * @summary List exercises for a workout
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExercises(userId: number, workoutId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListExercisesResponse> {
            return localVarFp.listExercises(userId, workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing exercise
         * @summary Update exercise
         * @param {number} userId User ID
         * @param {number} workoutId Workout ID
         * @param {number} exerciseId Exercise ID
         * @param {CreateExerciseRequest} createExerciseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExercise(userId: number, workoutId: number, exerciseId: number, createExerciseRequest: CreateExerciseRequest, options?: RawAxiosRequestConfig): AxiosPromise<Exercise> {
            return localVarFp.updateExercise(userId, workoutId, exerciseId, createExerciseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExercisesApi - object-oriented interface
 * @export
 * @class ExercisesApi
 * @extends {BaseAPI}
 */
export class ExercisesApi extends BaseAPI {
    /**
     * Add a new exercise to a workout (cardio or weight training)
     * @summary Create a new exercise
     * @param {number} userId User ID
     * @param {number} workoutId Workout ID
     * @param {CreateExerciseRequest} createExerciseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public createExercise(userId: number, workoutId: number, createExerciseRequest: CreateExerciseRequest, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).createExercise(userId, workoutId, createExerciseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an exercise from a workout
     * @summary Delete exercise
     * @param {number} userId User ID
     * @param {number} workoutId Workout ID
     * @param {number} exerciseId Exercise ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public deleteExercise(userId: number, workoutId: number, exerciseId: number, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).deleteExercise(userId, workoutId, exerciseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific exercise by its ID
     * @summary Get exercise by ID
     * @param {number} userId User ID
     * @param {number} workoutId Workout ID
     * @param {number} exerciseId Exercise ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public getExerciseById(userId: number, workoutId: number, exerciseId: number, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).getExerciseById(userId, workoutId, exerciseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all exercises for a specific workout
     * @summary List exercises for a workout
     * @param {number} userId User ID
     * @param {number} workoutId Workout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public listExercises(userId: number, workoutId: number, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).listExercises(userId, workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing exercise
     * @summary Update exercise
     * @param {number} userId User ID
     * @param {number} workoutId Workout ID
     * @param {number} exerciseId Exercise ID
     * @param {CreateExerciseRequest} createExerciseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExercisesApi
     */
    public updateExercise(userId: number, workoutId: number, exerciseId: number, createExerciseRequest: CreateExerciseRequest, options?: RawAxiosRequestConfig) {
        return ExercisesApiFp(this.configuration).updateExercise(userId, workoutId, exerciseId, createExerciseRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send a new message in a conversation
         * @summary Create a new message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage: async (userId: number, conversationId: number, createMessageRequest: CreateMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createMessage', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('createMessage', 'conversationId', conversationId)
            // verify required parameter 'createMessageRequest' is not null or undefined
            assertParamExists('createMessage', 'createMessageRequest', createMessageRequest)
            const localVarPath = `/users/{userId}/conversations/{conversationId}/messages`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a message from a conversation
         * @summary Delete message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (userId: number, conversationId: number, messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteMessage', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteMessage', 'conversationId', conversationId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessage', 'messageId', messageId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}/messages/{messageId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific message by its ID
         * @summary Get message by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById: async (userId: number, conversationId: number, messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getMessageById', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getMessageById', 'conversationId', conversationId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessageById', 'messageId', messageId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}/messages/{messageId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all messages in a specific conversation
         * @summary List messages in a conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages: async (userId: number, conversationId: number, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listMessages', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('listMessages', 'conversationId', conversationId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}/messages`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Send a new message in a conversation
         * @summary Create a new message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessage(userId: number, conversationId: number, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(userId, conversationId, createMessageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.createMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a message from a conversation
         * @summary Delete message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(userId, conversationId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.deleteMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific message by its ID
         * @summary Get message by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageById(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageById(userId, conversationId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.getMessageById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all messages in a specific conversation
         * @summary List messages in a conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessages(userId: number, conversationId: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessages(userId, conversationId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.listMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * Send a new message in a conversation
         * @summary Create a new message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage(userId: number, conversationId: number, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.createMessage(userId, conversationId, createMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a message from a conversation
         * @summary Delete message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMessage(userId, conversationId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific message by its ID
         * @summary Get message by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.getMessageById(userId, conversationId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all messages in a specific conversation
         * @summary List messages in a conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(userId: number, conversationId: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMessagesResponse> {
            return localVarFp.listMessages(userId, conversationId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * Send a new message in a conversation
     * @summary Create a new message
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {CreateMessageRequest} createMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public createMessage(userId: number, conversationId: number, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).createMessage(userId, conversationId, createMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a message from a conversation
     * @summary Delete message
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {number} messageId Message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public deleteMessage(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).deleteMessage(userId, conversationId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific message by its ID
     * @summary Get message by ID
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {number} messageId Message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessageById(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).getMessageById(userId, conversationId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all messages in a specific conversation
     * @summary List messages in a conversation
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public listMessages(userId: number, conversationId: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).listMessages(userId, conversationId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate with Google and create a new user if they don\'t exist
         * @summary Google login
         * @param {GoogleLoginRequest} googleLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleLogin: async (googleLoginRequest: GoogleLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'googleLoginRequest' is not null or undefined
            assertParamExists('googleLogin', 'googleLoginRequest', googleLoginRequest)
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log out the current user
         * @summary Log out the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate with Google and create a new user if they don\'t exist
         * @summary Google login
         * @param {GoogleLoginRequest} googleLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleLogin(googleLoginRequest: GoogleLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleLogin(googleLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.googleLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Log out the current user
         * @summary Log out the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Retrieve the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate with Google and create a new user if they don\'t exist
         * @summary Google login
         * @param {GoogleLoginRequest} googleLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleLogin(googleLoginRequest: GoogleLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.googleLogin(googleLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Log out the current user
         * @summary Log out the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Retrieve the currently authenticated user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate with Google and create a new user if they don\'t exist
     * @summary Google login
     * @param {GoogleLoginRequest} googleLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public googleLogin(googleLoginRequest: GoogleLoginRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).googleLogin(googleLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log out the current user
     * @summary Log out the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkoutsApi - axios parameter creator
 * @export
 */
export const WorkoutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new workout session for a user
         * @summary Create a new workout
         * @param {number} userId User ID
         * @param {CreateWorkoutRequest} createWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkout: async (userId: number, createWorkoutRequest: CreateWorkoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createWorkout', 'userId', userId)
            // verify required parameter 'createWorkoutRequest' is not null or undefined
            assertParamExists('createWorkout', 'createWorkoutRequest', createWorkoutRequest)
            const localVarPath = `/users/{userId}/workouts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workout and all associated exercises
         * @summary Delete workout
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkout: async (workoutId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('deleteWorkout', 'workoutId', workoutId)
            const localVarPath = `/users/{userId}/workouts/{workoutId}`
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific workout by its ID
         * @summary Get workout by ID
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkoutById: async (workoutId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('getWorkoutById', 'workoutId', workoutId)
            const localVarPath = `/users/{userId}/workouts/{workoutId}`
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing workout
         * @summary Update workout
         * @param {number} workoutId Workout ID
         * @param {UpdateWorkoutRequest} updateWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkout: async (workoutId: number, updateWorkoutRequest: UpdateWorkoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workoutId' is not null or undefined
            assertParamExists('updateWorkout', 'workoutId', workoutId)
            // verify required parameter 'updateWorkoutRequest' is not null or undefined
            assertParamExists('updateWorkout', 'updateWorkoutRequest', updateWorkoutRequest)
            const localVarPath = `/users/{userId}/workouts/{workoutId}`
                .replace(`{${"workoutId"}}`, encodeURIComponent(String(workoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List workouts for a user
         * @param {number} userId User ID
         * @param {string} [year] Filter by year (YYYY format)
         * @param {string} [month] Filter by month (MM format)
         * @param {string} [day] Filter by day (DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdWorkoutsGet: async (userId: number, year?: string, month?: string, day?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdWorkoutsGet', 'userId', userId)
            const localVarPath = `/users/{userId}/workouts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (day !== undefined) {
                localVarQueryParameter['day'] = day;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkoutsApi - functional programming interface
 * @export
 */
export const WorkoutsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkoutsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new workout session for a user
         * @summary Create a new workout
         * @param {number} userId User ID
         * @param {CreateWorkoutRequest} createWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkout(userId: number, createWorkoutRequest: CreateWorkoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWorkoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkout(userId, createWorkoutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.createWorkout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a workout and all associated exercises
         * @summary Delete workout
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkout(workoutId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkout(workoutId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.deleteWorkout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific workout by its ID
         * @summary Get workout by ID
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkoutById(workoutId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkoutById(workoutId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.getWorkoutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing workout
         * @summary Update workout
         * @param {number} workoutId Workout ID
         * @param {UpdateWorkoutRequest} updateWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkout(workoutId: number, updateWorkoutRequest: UpdateWorkoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkout(workoutId, updateWorkoutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.updateWorkout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List workouts for a user
         * @param {number} userId User ID
         * @param {string} [year] Filter by year (YYYY format)
         * @param {string} [month] Filter by month (MM format)
         * @param {string} [day] Filter by day (DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdWorkoutsGet(userId: number, year?: string, month?: string, day?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWorkoutsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdWorkoutsGet(userId, year, month, day, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkoutsApi.usersUserIdWorkoutsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkoutsApi - factory interface
 * @export
 */
export const WorkoutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkoutsApiFp(configuration)
    return {
        /**
         * Create a new workout session for a user
         * @summary Create a new workout
         * @param {number} userId User ID
         * @param {CreateWorkoutRequest} createWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkout(userId: number, createWorkoutRequest: CreateWorkoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateWorkoutResponse> {
            return localVarFp.createWorkout(userId, createWorkoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a workout and all associated exercises
         * @summary Delete workout
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkout(workoutId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkout(workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific workout by its ID
         * @summary Get workout by ID
         * @param {number} workoutId Workout ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkoutById(workoutId: number, options?: RawAxiosRequestConfig): AxiosPromise<Workout> {
            return localVarFp.getWorkoutById(workoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing workout
         * @summary Update workout
         * @param {number} workoutId Workout ID
         * @param {UpdateWorkoutRequest} updateWorkoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkout(workoutId: number, updateWorkoutRequest: UpdateWorkoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workout> {
            return localVarFp.updateWorkout(workoutId, updateWorkoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List workouts for a user
         * @param {number} userId User ID
         * @param {string} [year] Filter by year (YYYY format)
         * @param {string} [month] Filter by month (MM format)
         * @param {string} [day] Filter by day (DD format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdWorkoutsGet(userId: number, year?: string, month?: string, day?: string, options?: RawAxiosRequestConfig): AxiosPromise<ListWorkoutsResponse> {
            return localVarFp.usersUserIdWorkoutsGet(userId, year, month, day, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkoutsApi - object-oriented interface
 * @export
 * @class WorkoutsApi
 * @extends {BaseAPI}
 */
export class WorkoutsApi extends BaseAPI {
    /**
     * Create a new workout session for a user
     * @summary Create a new workout
     * @param {number} userId User ID
     * @param {CreateWorkoutRequest} createWorkoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public createWorkout(userId: number, createWorkoutRequest: CreateWorkoutRequest, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).createWorkout(userId, createWorkoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a workout and all associated exercises
     * @summary Delete workout
     * @param {number} workoutId Workout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public deleteWorkout(workoutId: number, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).deleteWorkout(workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific workout by its ID
     * @summary Get workout by ID
     * @param {number} workoutId Workout ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public getWorkoutById(workoutId: number, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).getWorkoutById(workoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing workout
     * @summary Update workout
     * @param {number} workoutId Workout ID
     * @param {UpdateWorkoutRequest} updateWorkoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public updateWorkout(workoutId: number, updateWorkoutRequest: UpdateWorkoutRequest, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).updateWorkout(workoutId, updateWorkoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List workouts for a user
     * @param {number} userId User ID
     * @param {string} [year] Filter by year (YYYY format)
     * @param {string} [month] Filter by month (MM format)
     * @param {string} [day] Filter by day (DD format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkoutsApi
     */
    public usersUserIdWorkoutsGet(userId: number, year?: string, month?: string, day?: string, options?: RawAxiosRequestConfig) {
        return WorkoutsApiFp(this.configuration).usersUserIdWorkoutsGet(userId, year, month, day, options).then((request) => request(this.axios, this.basePath));
    }
}



