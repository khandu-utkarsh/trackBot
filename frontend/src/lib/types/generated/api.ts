/* tslint:disable */
/* eslint-disable */
/**
 * TrackBot App API
 * Comprehensive API for the TrackBot Application helping in logging workouts, exercises and nutrition using AI.  This API provides endpoints for: - User management - Workout tracking and management - Exercise logging (cardio and weight training) - AI conversation and messaging  All timestamps are in ISO 8601 format (UTC). 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: utkarshkhandelwal2011@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Represents a conversation.
 * @export
 * @interface Conversation
 */
export interface Conversation {
    /**
     * Unique ID for the conversation.
     * @type {number}
     * @memberof Conversation
     */
    'id': number;
    /**
     * ID of the user.
     * @type {number}
     * @memberof Conversation
     */
    'user_id': number;
    /**
     * Conversation title.
     * @type {string}
     * @memberof Conversation
     */
    'title': string;
    /**
     * Timestamp of update.
     * @type {string}
     * @memberof Conversation
     */
    'updated_at': string;
}
/**
 * Request to create a conversation.
 * @export
 * @interface CreateConversationRequest
 */
export interface CreateConversationRequest {
    /**
     * Title of the conversation.
     * @type {string}
     * @memberof CreateConversationRequest
     */
    'title': string;
}
/**
 * Response after creating a conversation.
 * @export
 * @interface CreateConversationResponse
 */
export interface CreateConversationResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateConversationResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateConversationResponse
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof CreateConversationResponse
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof CreateConversationResponse
     */
    'updated_at': string;
}
/**
 * Payload to create a new message.
 * @export
 * @interface CreateMessageRequest
 */
export interface CreateMessageRequest {
    /**
     * Langchain message json.
     * @type {string}
     * @memberof CreateMessageRequest
     */
    'langchain_message': string;
    /**
     * 
     * @type {MessageType}
     * @memberof CreateMessageRequest
     */
    'message_type': MessageType;
}


/**
 * Request to delete a conversation and all its messages.
 * @export
 * @interface DeleteConversationRequest
 */
export interface DeleteConversationRequest {
    /**
     * Confirmation flag to prevent accidental deletion.
     * @type {boolean}
     * @memberof DeleteConversationRequest
     */
    'confirm'?: boolean;
}
/**
 * Response after successfully deleting a conversation and its messages.
 * @export
 * @interface DeleteConversationResponse
 */
export interface DeleteConversationResponse {
    /**
     * ID of the deleted conversation.
     * @type {number}
     * @memberof DeleteConversationResponse
     */
    'id': number;
    /**
     * Title of the deleted conversation.
     * @type {string}
     * @memberof DeleteConversationResponse
     */
    'title': string;
    /**
     * Timestamp when the conversation was deleted.
     * @type {string}
     * @memberof DeleteConversationResponse
     */
    'deleted_at': string;
    /**
     * Number of messages that were deleted along with the conversation.
     * @type {number}
     * @memberof DeleteConversationResponse
     */
    'messages_deleted_count': number;
}
/**
 * Payload for Google OAuth login.
 * @export
 * @interface GoogleLoginRequest
 */
export interface GoogleLoginRequest {
    /**
     * Google JWT credential token
     * @type {string}
     * @memberof GoogleLoginRequest
     */
    'googleToken': string;
}
/**
 * Response containing a list of conversations.
 * @export
 * @interface ListConversationsResponse
 */
export interface ListConversationsResponse {
    /**
     * 
     * @type {Array<Conversation>}
     * @memberof ListConversationsResponse
     */
    'conversations': Array<Conversation>;
}
/**
 * 
 * @export
 * @interface ListMessagesRequest
 */
export interface ListMessagesRequest {
    /**
     * 
     * @type {number}
     * @memberof ListMessagesRequest
     */
    'conversation_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListMessagesRequest
     */
    'user_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListMessagesRequest
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ListMessagesRequest
     */
    'offset'?: number;
}
/**
 * Response containing a list of messages.
 * @export
 * @interface ListMessagesResponse
 */
export interface ListMessagesResponse {
    /**
     * 
     * @type {Array<Message>}
     * @memberof ListMessagesResponse
     */
    'messages': Array<Message>;
}
/**
 * Represents a message in a conversation.
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * Unique identifier for the message.
     * @type {number}
     * @memberof Message
     */
    'id': number;
    /**
     * Conversation ID this message belongs to.
     * @type {number}
     * @memberof Message
     */
    'conversation_id': number;
    /**
     * User ID who sent the message.
     * @type {number}
     * @memberof Message
     */
    'user_id': number;
    /**
     * Langchain message json.
     * @type {string}
     * @memberof Message
     */
    'langchain_message': string;
    /**
     * 
     * @type {MessageType}
     * @memberof Message
     */
    'message_type': MessageType;
    /**
     * Creation timestamp.
     * @type {string}
     * @memberof Message
     */
    'created_at'?: string;
}


/**
 * Type of message sender
 * @export
 * @enum {string}
 */

export const MessageType = {
    User: 'user',
    Assistant: 'assistant',
    Other: 'other'
} as const;

export type MessageType = typeof MessageType[keyof typeof MessageType];


/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Error code
     * @type {string}
     * @memberof ModelError
     */
    'code': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * Additional error details
     * @type {{ [key: string]: any; }}
     * @memberof ModelError
     */
    'details'?: { [key: string]: any; };
}
/**
 * Request to update a conversation.
 * @export
 * @interface UpdateConversationRequest
 */
export interface UpdateConversationRequest {
    /**
     * Updated title of the conversation.
     * @type {string}
     * @memberof UpdateConversationRequest
     */
    'title'?: string;
}
/**
 * Represents a registered user in the system.
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier for the user. Created by the database.
     * @type {number}
     * @memberof User
     */
    'id': number;
    /**
     * User\'s email address. This is the primary key for the user and obtained from Google Auth.
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * User\'s full name from Google profile.
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * User\'s profile picture URL from Google.
     * @type {string}
     * @memberof User
     */
    'picture': string;
    /**
     * Timestamp when the user was created. Created by the database.
     * @type {string}
     * @memberof User
     */
    'created_at'?: string | null;
}

/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Start a new conversation with the AI assistant
         * @summary Create a new conversation
         * @param {number} userId User ID
         * @param {CreateConversationRequest} createConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation: async (userId: number, createConversationRequest: CreateConversationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createConversation', 'userId', userId)
            // verify required parameter 'createConversationRequest' is not null or undefined
            assertParamExists('createConversation', 'createConversationRequest', createConversationRequest)
            const localVarPath = `/users/{userId}/conversations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createConversationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a conversation and all associated messages
         * @summary Delete conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {DeleteConversationRequest} [deleteConversationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation: async (userId: number, conversationId: number, deleteConversationRequest?: DeleteConversationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteConversation', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteConversation', 'conversationId', conversationId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteConversationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific conversation by its ID
         * @summary Get conversation by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationById: async (userId: number, conversationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getConversationById', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getConversationById', 'conversationId', conversationId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all conversations for a specific user
         * @summary List conversations for a user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listConversations', 'userId', userId)
            const localVarPath = `/users/{userId}/conversations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing conversation
         * @summary Update conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {UpdateConversationRequest} updateConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation: async (userId: number, conversationId: number, updateConversationRequest: UpdateConversationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateConversation', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('updateConversation', 'conversationId', conversationId)
            // verify required parameter 'updateConversationRequest' is not null or undefined
            assertParamExists('updateConversation', 'updateConversationRequest', updateConversationRequest)
            const localVarPath = `/users/{userId}/conversations/{conversationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConversationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Start a new conversation with the AI assistant
         * @summary Create a new conversation
         * @param {number} userId User ID
         * @param {CreateConversationRequest} createConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversation(userId: number, createConversationRequest: CreateConversationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversation(userId, createConversationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.createConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a conversation and all associated messages
         * @summary Delete conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {DeleteConversationRequest} [deleteConversationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversation(userId: number, conversationId: number, deleteConversationRequest?: DeleteConversationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversation(userId, conversationId, deleteConversationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.deleteConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific conversation by its ID
         * @summary Get conversation by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationById(userId: number, conversationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Conversation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationById(userId, conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.getConversationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all conversations for a specific user
         * @summary List conversations for a user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversations(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConversationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConversations(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.listConversations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing conversation
         * @summary Update conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {UpdateConversationRequest} updateConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversation(userId: number, conversationId: number, updateConversationRequest: UpdateConversationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Conversation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversation(userId, conversationId, updateConversationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversationsApi.updateConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationsApiFp(configuration)
    return {
        /**
         * Start a new conversation with the AI assistant
         * @summary Create a new conversation
         * @param {number} userId User ID
         * @param {CreateConversationRequest} createConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation(userId: number, createConversationRequest: CreateConversationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateConversationResponse> {
            return localVarFp.createConversation(userId, createConversationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a conversation and all associated messages
         * @summary Delete conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {DeleteConversationRequest} [deleteConversationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation(userId: number, conversationId: number, deleteConversationRequest?: DeleteConversationRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteConversationResponse> {
            return localVarFp.deleteConversation(userId, conversationId, deleteConversationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific conversation by its ID
         * @summary Get conversation by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationById(userId: number, conversationId: number, options?: RawAxiosRequestConfig): AxiosPromise<Conversation> {
            return localVarFp.getConversationById(userId, conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all conversations for a specific user
         * @summary List conversations for a user
         * @param {number} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversations(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<ListConversationsResponse> {
            return localVarFp.listConversations(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing conversation
         * @summary Update conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {UpdateConversationRequest} updateConversationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation(userId: number, conversationId: number, updateConversationRequest: UpdateConversationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Conversation> {
            return localVarFp.updateConversation(userId, conversationId, updateConversationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversationsApi - object-oriented interface
 * @export
 * @class ConversationsApi
 * @extends {BaseAPI}
 */
export class ConversationsApi extends BaseAPI {
    /**
     * Start a new conversation with the AI assistant
     * @summary Create a new conversation
     * @param {number} userId User ID
     * @param {CreateConversationRequest} createConversationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public createConversation(userId: number, createConversationRequest: CreateConversationRequest, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).createConversation(userId, createConversationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a conversation and all associated messages
     * @summary Delete conversation
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {DeleteConversationRequest} [deleteConversationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public deleteConversation(userId: number, conversationId: number, deleteConversationRequest?: DeleteConversationRequest, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).deleteConversation(userId, conversationId, deleteConversationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific conversation by its ID
     * @summary Get conversation by ID
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public getConversationById(userId: number, conversationId: number, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).getConversationById(userId, conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all conversations for a specific user
     * @summary List conversations for a user
     * @param {number} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public listConversations(userId: number, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).listConversations(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing conversation
     * @summary Update conversation
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {UpdateConversationRequest} updateConversationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApi
     */
    public updateConversation(userId: number, conversationId: number, updateConversationRequest: UpdateConversationRequest, options?: RawAxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).updateConversation(userId, conversationId, updateConversationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send a new message in a conversation
         * @summary Create a new message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage: async (userId: number, conversationId: number, createMessageRequest: CreateMessageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createMessage', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('createMessage', 'conversationId', conversationId)
            // verify required parameter 'createMessageRequest' is not null or undefined
            assertParamExists('createMessage', 'createMessageRequest', createMessageRequest)
            const localVarPath = `/users/{userId}/conversations/{conversationId}/messages`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a message from a conversation
         * @summary Delete message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (userId: number, conversationId: number, messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteMessage', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteMessage', 'conversationId', conversationId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessage', 'messageId', messageId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}/messages/{messageId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific message by its ID
         * @summary Get message by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById: async (userId: number, conversationId: number, messageId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getMessageById', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getMessageById', 'conversationId', conversationId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessageById', 'messageId', messageId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}/messages/{messageId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all messages in a specific conversation
         * @summary List messages in a conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages: async (userId: number, conversationId: number, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listMessages', 'userId', userId)
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('listMessages', 'conversationId', conversationId)
            const localVarPath = `/users/{userId}/conversations/{conversationId}/messages`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"conversationId"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Send a new message in a conversation
         * @summary Create a new message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessage(userId: number, conversationId: number, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(userId, conversationId, createMessageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.createMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a message from a conversation
         * @summary Delete message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(userId, conversationId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.deleteMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific message by its ID
         * @summary Get message by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageById(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageById(userId, conversationId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.getMessageById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all messages in a specific conversation
         * @summary List messages in a conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessages(userId: number, conversationId: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessages(userId, conversationId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.listMessages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * Send a new message in a conversation
         * @summary Create a new message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {CreateMessageRequest} createMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage(userId: number, conversationId: number, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListMessagesResponse> {
            return localVarFp.createMessage(userId, conversationId, createMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a message from a conversation
         * @summary Delete message
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMessage(userId, conversationId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific message by its ID
         * @summary Get message by ID
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} messageId Message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.getMessageById(userId, conversationId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all messages in a specific conversation
         * @summary List messages in a conversation
         * @param {number} userId User ID
         * @param {number} conversationId Conversation ID
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessages(userId: number, conversationId: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListMessagesResponse> {
            return localVarFp.listMessages(userId, conversationId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * Send a new message in a conversation
     * @summary Create a new message
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {CreateMessageRequest} createMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public createMessage(userId: number, conversationId: number, createMessageRequest: CreateMessageRequest, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).createMessage(userId, conversationId, createMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a message from a conversation
     * @summary Delete message
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {number} messageId Message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public deleteMessage(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).deleteMessage(userId, conversationId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific message by its ID
     * @summary Get message by ID
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {number} messageId Message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getMessageById(userId: number, conversationId: number, messageId: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).getMessageById(userId, conversationId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all messages in a specific conversation
     * @summary List messages in a conversation
     * @param {number} userId User ID
     * @param {number} conversationId Conversation ID
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public listMessages(userId: number, conversationId: number, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).listMessages(userId, conversationId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate with Google and create a new user if they don\'t exist
         * @summary Google login
         * @param {GoogleLoginRequest} googleLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleLogin: async (googleLoginRequest: GoogleLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'googleLoginRequest' is not null or undefined
            assertParamExists('googleLogin', 'googleLoginRequest', googleLoginRequest)
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log out the current user
         * @summary Log out the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate with Google and create a new user if they don\'t exist
         * @summary Google login
         * @param {GoogleLoginRequest} googleLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleLogin(googleLoginRequest: GoogleLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleLogin(googleLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.googleLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Log out the current user
         * @summary Log out the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Retrieve the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate with Google and create a new user if they don\'t exist
         * @summary Google login
         * @param {GoogleLoginRequest} googleLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleLogin(googleLoginRequest: GoogleLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.googleLogin(googleLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Log out the current user
         * @summary Log out the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Retrieve the currently authenticated user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate with Google and create a new user if they don\'t exist
     * @summary Google login
     * @param {GoogleLoginRequest} googleLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public googleLogin(googleLoginRequest: GoogleLoginRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).googleLogin(googleLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log out the current user
     * @summary Log out the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}



